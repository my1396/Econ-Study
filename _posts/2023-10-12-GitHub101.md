---
layout: post
title: GitHub Tutorial
tag: programming
update: 2023-10-12
---

$$
\newcommand{\indep}{\perp \!\!\! \perp}
$$

[Github Education Benefit](https://education.github.com/discount_requests/application)

- Apply for free [GitHub Team](https://docs.github.com/en/get-started/learning-about-github/githubs-plans), which allows unlimited users and private repositories. 


Install 

```bash
brew install git
```

Log in to your GitHub account

```bash
git config --global user.name "Menghan Yuan"
git config --global user.email my1396@nyu.edu
```

## Push an existing repository

1. Initialize an existing project to start tracking with `git`.

   - Go into the directory containing the project.

   - Type `git init`.

   - Type `git add .` to add all of the relevant files. This step is called "staging."
     - You’ll probably want to create a `.gitignore` file right away, to indicate all of the files you don’t want to track. Use `git add .gitignore`, too.
     
   - Type `git commit -m 'commit message'`.

     `commit` records changes to the local repository.

     git generally requires a non-empty commit message.

     

2. Create a online repo and connect it to your local git project.

   <ol type="a">
   <li> Go to <a href="https://github.com/">GitHub</a>, click the <a href="https://github.com/new">new repository</a> button in the top-right. You’ll have an option there to initialize the repository with a README file.
   <img src="https://drive.google.com/thumbnail?id=1N1bOGsiKoVIp312snyOJg-3UJKWwgYzV&sz=w1000" alt="new GitHub repo" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />
   </li>
   <li> Click the “Create repository” button. </li>
   <li> Connect your local repo to the remote repo you just created using the following cmds. 
     <pre><code># add repo name "origin" to the remote repo at the URL
   $ git remote add origin https://github.com/my1396/Damage-Function.git
   # rename the "current" local branch to main
   $ git branch -M main 
   # push update from the current local branch (main) to remote (origin) repo's main branch; -u is a shortname for --set-upstream; first parameter is upstream then 2nd parameter is local repo
   # local and remote branch names should be matching
   $ git push -u origin main </code></pre>
   Note that <code>main</code> can be replaced by <code>master</code> for older repositories. 
   </li>
   <li> Then use GitHub Desktop to manage the repo committing, syncing, ..., later on. </li>
   </ol>

Ref: <https://kbroman.org/github_tutorial/pages/init.html>

___

Q: Is it worth using GitHub Desktop?  
A: Yes and no. It is useful if you just want to do basic management of your repositories. There are many things you cannot do with GitHub Desktop, e.g., you cannot rename a file. You need to do it with command line or using online GitHub. Github desktop hides a lot of the details of handling git, making it difficult to debug. Additionally, git integration into almost any IDE is available and possibly more powerful, such as VS code git extension allows to rename a file directly. 

___

**Troubleshooting**

Error: `git pull origin main` returns 

> You have divergent branches and need to specify how to reconcile them.  
>You can do so by running one of the following commands sometime before your next pull:
> 
>`git config pull.rebase false # merge`
> 
>`git config pull.rebase true  # rebase`
> 
>`git config pull.ff only      # fast-forward only`
> 
>fatal: Need to specify how to reconcile divergent branches.

"Divergent branches" 常出现于 remote repo 初始化时不是空的。这种情况下，需要先 `git pull` 合并 remote 和 local，然后再 `git push`。

Fix: run `git pull origin main --rebase`.





___

## Github common commands

**Documentation**:  <https://git-scm.com/docs/git-push>

You can change the language using the top-right language tab.

<img src="https://drive.google.com/thumbnail?id=1W6Dx5k4mWS9Sl-cvYDJYfxcCV_H-RGne&sz=w1000" alt="Git References" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />

中文：<https://git-scm.com/book/zh/v2/Git-分支-分支简介>

<figure style="display: flex; flex-direction: column; align-items: center; text-align: center;">
<img src="https://media.datacamp.com/cms/ad_4nxe0ek49gw2mktdmdf7t8-xt7ebqkebffg-sbfm5zebhaxuqcobtk2ekm3wm4e8usyempsoxwr9wvzwansznvcqqbukreymgqfcibhcxhy_vzzf2jte2rqpzgsrsknc6us8vj8he.jpeg" alt="" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />
<figcaption> Git workflow.</figcaption>
</figure>


- working direcotry: the files you are actively working on.
- staging area: a file, also called "index", that lives in your `.git` directory. It acts as a middle ground between the working directory and the repository.
- repository: where Git stores all the changes as a series of commits.


[`git add`](https://git-scm.com/docs/git-add) Add file contents to the staging area.

`git add .`  recursively stage changes from the current working directory

`git add -A | --all` stage all changes in the Git repository



Q: How to view the commit history?  
A: Use `git log`. Executing the command would display:

<img src="https://media.datacamp.com/cms/google/ad_4nxehoftxdd-9sh1nrxsjhvufwverjojcgygg-6ifk-hwq4ql0uq8yt6hoqefka5rmajoeypra6by2byeha6slco8abv1k5t7rqnvxx6s-9e1ww3xw-yrcbpc66i6pf2aqbmryswkbojbb4o6y1ouwgt3pv8.png" alt="Git Commits" style="display: block; margin-right: auto; margin-left: auto; zoom:100%;" />

To navigate the list of commits, use the up and down arrow keys. To exit, press `q`.



Q: Should I push every single commit?   
A: Committing to your local repository you are basically saying "I trust this code." When you feel you want your teammates to see your changes, you `push` to remote. If you collaborate with others, pushing more frequently would have a lower risk of conflict.



Q: What are local and remote repositories?   
A: 

- Local repositories are about tracking your changes to protect the work you do. 
- Remote repositories are for distributing the work to all your teammates and tracking everyone's changes. 



### Git Remote Configurations

`git remote` Creating and modifying git remote configurations

Commonly used `git remote` subcommands:

- Create a **new** connection to a remote repository.

  ```bash
  git remote add <name> <url>
  # Example: add repo name "origin" to the remote repo at the URL
  git remote add origin https://github.com/my1396/Damage-Function.git
  ```

  After adding a remote, you’ll be able to use `＜name＞` as a convenient shortcut for `＜url＞` in other Git commands.

- **Remove** the connection to the remote repository called `＜name＞`.

  ```bash
  git remote rm <name>
  ```

- **Rename** a remote connection from `＜old-name＞` to `＜new-name＞`.

  ```bash
  git remote rename <old-name> <new-name>
  ```

- Show your remotes

  `git remote` without any flags will list previously stored remote connections

  ```bash
  $ git remote
  origin
  ```
  
  `git remote [-v | --verbose]` show remote URL after name. `-v` stands for "verbose."

  ```bash
  $ git remote -v
  origin	https://github.com/my1396/Econ-Study.git (fetch)
  origin	https://github.com/my1396/Econ-Study.git (push)
  ```
  
  `git remote show <remote-repo-name>` give detailed output on the configuration of a remote given by  `<remote-repo-name>`.
  
  ```bash
  $ git remote show origin  
  * remote origin
    Fetch URL: https://github.com/my1396/Econ-Study.git
    Push  URL: https://github.com/my1396/Econ-Study.git
    HEAD branch: main
    Remote branch:
      main tracked
    Local branch configured for 'git pull':
      main merges with remote main
    Local ref configured for 'git push':
      main pushes to main (up to date)
  ```
  
  



___

**Repo's <span style='color:#00CC66'>configuration file</span>** 

- Path: `./.git/config`

  `git remote add` command will modify the configuration file.

  You can directly edit the `./.git/config` file with a text editor.

- Looks like the following

  ```bash
  [core]
  	repositoryformatversion = 0
  	filemode = true
  	bare = false
  	logallrefupdates = true
  	ignorecase = true
  	precomposeunicode = true
  [remote "origin"]
  	url = https://github.com/my1396/R-Notes.git
  	fetch = +refs/heads/*:refs/remotes/origin/*
  [pull]
  	ff = only
  [branch "main"]
  	remote = origin
  	merge = refs/heads/main
  [lfs]
  	repositoryformatversion = 0
  ```

  - `url` tells `git fetch origin` where to fetch the repository
  - `fetch` refspec tells `git fetch origin` which names to create or update in your own repository.

___



`git rev-parse --is-inside-work-tree` 	check is a folder is a git repository. Which will print 'true' to STDOUT if you are in a git repos working tree.

-   Note that it still returns output to STDERR if you are outside of a git repo (and does not print 'false').



___



`git fetch`:  downloads commits, files from a remote repository into your local repo, but it doesn't integrate any of this new data into your working files. 

`git pull <remote>`: `fetch` + `merge`.  Directly **integrates** changes into your current working copy files. This command does two main things: 

- first, it executes `git fetch` which contacts the remote repository and pulls down any data it doesn't already have, including updates to branches and tags. 
- Second, it merges one of these branches (usually the corresponding branch) into your current branch, combining the remote changes with your local ones. 

Q: Why `git fetch` is safer?  
A:  `git fetch` will download the remote content and not alter the state of the local repository. Alternatively, `git pull` will download remote content and immediately attempt to change the local state to match that content. This may unintentionally cause the local repository to get in a conflicted state.

<u>Common options</u> of `git pull`:

`git pull <remote>`  Fetch the specified remote’s copy of the current branch and immediately merge it into the local copy.

`git pull --rebase <remote>`  fetches the remote content but does not create a new merge commit, Instead of using `git merge` to integrate the remote branch with the local one, use `git rebase`. 

Case scenario: you are working on `new-feature` and before you push, you `pull` the remote repo to make sure you have the latest code in case some has made changes.

```bash
# fectch + merge
git checkout new-feature
git fetch origin
git merge origin

# pull
git checkout new-feature
git pull --rebase origin # append your change to the main
```



___



`git push [options] <remote-repo> <remote-branch>`: update remote repository with local changes you committed. See [HERE](#git-push) for command arguments.

- `<remote-repo>`:     The <u>remote repository</u> that is the destination of a push operation. This parameter can be either a URL or the name of a remote.
- `<remote-branch>`:           The name of the <u>branch in the remote repository</u> where the changes should be pushed. 

You often encounter <span style='color:#00CC66'>`git push origin main`</span> when working with git. Why `origin` and `main`?

- `origin` is the <u>default name given to the remote repository</u> when you clone a repository. 

  It acts as a shorthand for the remote repository’s URL (e.g., a repository hosted on GitHub, GitLab, or another Git server).

  `origin` specifies the remote repository that should receive the changes.

- `main` is the name of a branch in your Git repository. 

  By convention, `main` often serves as the default branch for a repository. It typically contains the latest stable version of the code.

  The branch name specifies which branch in the remote repository should receive the changes. Without specifying the branch, Git might use a default branch or require additional configuration.



___

### Rename File

**<span style='color:#00CC66'>Rename</span> a file, a directory, or a symlink**

`git mv [<options>] <source> <destination> ` Move or rename a file, directory, or symlink.

- `<source>` 	which must exist and be either a file, symlink or directory
- `<destination>`  is the new file name, symlink or directory

Basic Syntax

To move or rename a file using git mv, simply specify the existing and new paths of the file after the command:

```bash
git mv ./old_directory/old_file.ext ./new_directory/new_file.ext
```

<u>Renaming or moving files</u> with `git mv` <u>preserves the file’s history</u> and is especially useful in collaborative development to maintain a clear and organized project structure.

- If you do the renaming manually, the change will be recorded as delete and add a new file, the changes of the file won't be preserved.

```bash
# if the file you plan to rename is in your current directory
# use file name directly
git mv gfg1.py gfg2.py 
```

<img src="https://drive.google.com/thumbnail?id=1CgtlOAOMsDlELGbSMZDg-FxquXAGkDww&sz=w1000" alt="Git mv" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />

**Troubleshooting**

> fatal: not under version control, source=_posts/2023-10-12-Bibli.md, destination=_posts/2023-10-12-Jekyll-Bibli.md

Cause: The error happens because the parent folder has special character (`_posts/`). 

Fix: Enclose file names with quotes.

```bash
git mv "_posts/2023-10-12-Bibli.md" "_posts/2023-10-12-Jekyll-Bibli.md"
```



___

`git rm` The primary function of `git rm` is to remove tracked files from the Git index. Additionally, `git rm` can be used to remove files from both the staging index and the working directory.

-   `-r` the option is shorthand for '<u>r</u>ecursive'. When operating in recursive mode `git rm` will remove a target directory and all the contents of that directory.
-   `--cached` The `--` separator option is used to explicitly distinguish between a list of file names and the arguments being passed to `git rm`. This is useful if some of the file names have syntax that might be mistaken for other options.
    -   The cached option specifies that the removal should happen only on the staging index. Working directory files will be left alone.

___

Q: Do I need to quote file names?  
A: Depends on your shell, has nothing to do with `git`.

Most shells "tokenize" the command line -- that is, split it into a sequence of discrete elements -- using whitespace. So, for example

```bash
rm one file
```

will attempt to remove a file named `one` and a file named `file`, whereas

```bash
rm 'one file'
```

will attempt to remove a single file named `one file`. 

The principle is

- it does NOT matter whether you quote when your file name/path does NOT contain spaces.
- when you write `commit` messages, usually write inside quotes as it is common to have spaces inside your message.



___



Git doesn't track directories, so it won't remove ones that become empty as a result of a merge or other change. However, you can use `git clean -fd` to remove untracked directories (the `-fd` flag means *f*orce removal of untracked files and directories).

`git restore .`   discards all *unstaged* files in current working directory use.

For one specific file use: `git restore <path/to/file/to/revert>`





___

### gitignore

Basic syntax of `.gitignore`:

- `foo/` will match a **directory** `foo` and <span class="env-green">**paths underneath it**</span>. `foo` and `/foo` have the same effect. The leading slash doesn't matter.

- `*` matches anything (zero, one, or more characters) except a slash `/`.

- `?` matches one single character except a slash `/`.

- A line starting with `#` serves as a comment.
  - To match files that begin with a hash, put a backslash ("`\`", escape character) in front of the first hash.



**Delete a file in `.gitignore` after you have already added it to the repo.**

How to make Git forget about a file that was tracked, but is now in `.gitignore`?

`.gitignore` is only for untracked files.

```bash
# This removes all files from the repository and adds them back (this time respecting the rules in your .gitignore).
git rm -rf --cached "Shared folder.Rproj"
git add .
git commit -m "clear cache"
git push
```

If you make changes to your repository, the workflow is `add` $\rightarrow$ `commit` $\rightarrow$ `push.`



**Undo local changes**

Until you push your changes to a remote repository, changes you make in Git are only in your local development environment.

When you make a change, but have not yet staged it, you can undo your work.

```bash
git reset --hard
```

Undo staged local changes:

```bash
git reset --hard
```

Undo committed local changes. When you commit to your local repository (`git commit`), Git records your changes. Because you did not push to a remote repository yet, your changes are not public (or shared with other developers). At this point, you can undo your changes.


--------------------------------------------------------------------------------

`git-blame`: Show what revision and author last modified each line of a file.


___

## Failure When Push Large Files

Github Error: 

- [RPC failed; HTTP 400 curl 22 The requested URL returned error: 400 Bad Request](https://stackoverflow.com/questions/62753648/rpc-failed-http-400-curl-22-the-requested-url-returned-error-400-bad-request)

- RPC failed; curl 55 Failed sending data to the peer send-pack: unexpected disconnect while reading sideband packet.

This is an HTTP buffer issue. Happens when you are pushing a large amount of data.

**Fix**: 

1. Increase the buffer will solve the issue. [Easiest solution] Or, 
2. you could push by small batches of changes. Or, 
3. use Git Large File Storage. 

```bash
git config http.postBuffer 524288000
git pull && git push
```

Q: what does `http.postBuffer` do?

A: This option changes the size of the buffer that Git uses when pushing data to a remote over HTTP or HTTPS.

> The default of httpBuffer size is set to 1MB for https. Please note the only acceptable values are 524288000 (500mb), 1048576000 (1 GB) and 2147483648 (2 GB). Anything above it, is considered out of range.

`git config http.postBuffer 524288000` will set the httpBuffer size to 500 MB.



To remove the file that you have already committed, you are going to need to reset your HEAD to the commit before the one that contains your file. Make sure you are performing a *soft reset.*

```
git reset --soft HEAD~1
```

1 is the number of commits you need to move back, can be greater than 1.



___

### Git Large File Storage

``` ./install.sh.``` install Git Large File Storage from source.

Go to the Git repository where you want to use Git LFS, select the file types you'd like Git LFS to manage (or directly edit your .gitattributes). You can configure additional file extensions at anytime.

```bash
git lfs track "*.psd"
git lfs track "*.png"
```

Now make sure .gitattributes is tracked. Your tracked files’ details are saved inside a `.gitattributes`so make sure to add `.gitattributes` to persist tracking when other users clone the project.

```bash
git add .gitattributes
```

You should then be able to safely add, commit and push!

```bash
git add file.png
git commit -m "Add design file"
git push origin main
```


___

## Revert a single file to a previous commit

Git doesn't keep version numbers for individual files. It just tracks content - a commit is essentially a snapshot of the work tree, along with some metadata (e.g. commit message). So, 

1. we have to know which commit has the version of the file we want. 
2. Once we know that, we'll need to make a new commit reverting the file to that state. 


To find the commit, we can use `git log -- <file>` to see the history of changes to that file. 

```bash
git log -- path/to/file
```

You'll be able to find the SHA1 (hash) of the commit with the version of the file you want. Now, all you have to do is this:

```bash
# get the version of the file from the given commit
git checkout <commit-sha1> -- path/to/file
# commit this modification
git commit -m "Revert path/to/file to <commit-sha1>"
```

___

## git diff tool

### How to use git diff

`git diff` without arguments, it compares your Working Directory to the Staging Area, showing changes you've made but haven't staged yet.

`git diff --staged` compares the Staging Area to the last commit, showing what will be included in your next commit.

`git diff HEAD` compares your Working Directory directly to the last commit, showing all uncommitted changes regardless of staging status.

`git diff commit1-hash commit2-hash` compares two specific commits, showing changes between them.

To see changes with specific files, use `git diff <file-path>`.


A quick preview of your Working Directory changes compared to the last commit can be done with the tool bar in the Editor view.

Just click on the top right icon - "Open changes". This will show changes for current file.

<img src="https://drive.google.com/thumbnail?id=1HLSbA74H9_s54rNtQb7bVTyZFQFSMF-g&sz=w1000" alt="" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />

And go back to the file, clicking on the top right icon - "Open file"

<img src="https://drive.google.com/thumbnail?id=1v4nx6z5jVn8j5RzGheBiU2la4OiKOuLQ&sz=w1000" alt="" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />


___

### Graphical diff tool

You can use an external **visual diff tool** to compare changes between commits, branches, files, etc.


The following configurations in `.gitconfig` is for git to use VS Code as the diff and merge tool.

```bash
[core]
  editor = code --wait
[diff]
  tool = vscode
[difftool "vscode"]
  cmd = code --wait --diff $LOCAL $REMOTE
[merge]
  tool = vscode
[mergetool "vscode"]
  cmd = code --wait $MERGED
```

--------------------------------------------------------------------------------

#### Set default editor

The default editor is `vim`. You can change it to VS Code. 


Prerequisite: Make sure the `code` command is available in your PATH. It is possible that this wasn’t done as part of your installation.

To test this, run `code --version` in your terminal. If you see the version number, you're good to go.

Install `code` command in PATH: Open command palette (⇧⌘P) and type 'shell command' to find the `Shell Command: Install 'code' command in PATH` command.

You can either use the above global git config file, or equivalently, using command-line:

```bash
git config --global core.editor "code --wait"
# Open new window opens each time
git config --global core.editor 'code --wait --new-window'
```

- If you only want to change it for your current project, run the same command without the `--global` git flag.

How to set it back to the default?

```bash
git config --global --unset core.editor
```

--------------------------------------------------------------------------------

#### Set default diff tool

The default diff tool is `vimdiff`. You can either use the above global git config file, or equivalently, using command-line:

```bash
git config --global diff.tool vscode
git config --global difftool.vscode.cmd 'code --wait --diff $LOCAL $REMOTE'
```

If you're not feeling VS Code as your diff tool, you run the command `git difftool --tool-help` to see more options.

--------------------------------------------------------------------------------

#### Set default merge tool

There is no default merge tool set.

When there is a conflict, you will get error messages when you try to pull or push changes. Running `git mergetool` will allow you to resolve conflicts.

```bash
git config --global merge.tool vscode
git config --global mergetool.vscode.cmd 'code --wait $MERGED'
```

If you're not feeling VS Code as your merge tool, you run the command `git mergetool --tool-help` to see more options.

Ref:

- <https://www.roboleary.net/vscode/2020/09/15/vscode-git>

___

## Branch management

Q: What are different branches for?  
A: There are different types of branches, including the main branch (usually called "master" or "main"), feature branches, release branches, and hotfix branches. Each branch serves a specific purpose and helps developers manage their codebase better.

___

Q: Can I clone a specific branch?  
A: Yes.  Run the following code

```bash
git clone --branch <branchname> --single-branch <remote-repo-url>
```

`--branch` (two hyphens) can be replaced by `-b` (one hyphen).

Cloning a specific branch in Git is a useful feature that allows developers to work on specific features or bug fixes without cloning the entire repository.

___

But you may want to clone all branches first, and then work on your own branch. When you finish, you can merge your updates into the `main` branch. This makes it easier to compare differences and make sure your branch is in sync with with the `main` branch.

To this end, you need to run

```bash
// this will clone all branches
git clone <remote-repo-url>
```

Then you could `checkout` to one specific branch to work.

These could be achieved by one combined command too with the argument `--branch <branchname>`.

```bash
// clone all branch then switch to <branchname>
git clone --branch <branchname> <remote-repo-url>
// or using -b alias for --branch
git clone -b <branchname> <remote-repo-url>
```

A downside of `clone` the whole repository is that you will fetch all files from each branch. You might not want this if the repository has a large history.



___

### Collaborations

You can also open Pull Requests between separate branches on GitHub. This often presents a good way for <span style='color:#00CC66'>collaborating</span> with people who have access to the same repository. You don't want to all be pushing to the `main` branch all the time. Instead, each person can create their own branch, work separately, and then open a pull request to merge that branch into `main`.

If you create a local branch in your repo, you can push it to GitHub as follows:

First, make sure that you are *on* the branch that you want to push:

```bash
$ git branch
```

Then run 

```bash
# -u option will set up a link between local and remote upstream branches
# -u is used when you have your initial push of your update
$ git push -u origin <branch-name>
```

to push the current local (active) branch to the remote branch `<branch-name>`. 

`-u` is a shortname for `--set-upstream`; 

- the 1st parameter is the upstream repo, 
- the 2nd parameter is the local repo.

After establishing the upstream at the initial push, you can use `git push` with no argument for later updates.

Note that branch names should be matching between local and remote repositories. When you run `git push origin main`, Git pushes the commits from your local `main` branch to the corresponding `main` branch on the remote repository.



- `git branch` with no argument (or with `--list`) will print a list of branches linked to the current repo. 

  Could be used to check which branch I am currently on. Your current branch (i.e., the branch that `HEAD` points to) is prefixed by `*`  and highlighted in green.

  ```bash
  (base) menghan@Nord16 Shared folder $ git branch
  * Menghan
    coauthor
    master
  ```

  

- `git branch Menghan` <span style='color:#00CC66'>create a branch</span> called `Menghan`

  ```bash
  // create a branch
  $ git branch <branch-name>
  // switch to the branch
  $ git checkout <branch-name>
  ```

  Or, there is a combined command first creating a branch then switching to it

  ```bash
  // create a branch and switch to the branch
  $ git checkout -b <branch-name>
  ```

  Now we want to add this branch remotely. All we have to do is push it to our Git provider such as GitHub using the command below:

  ```bash
  $ git push -u origin <branch-name>
  ```

  

- `git branch -d Menghan` <span style='color:#00CC66'>delete the local branch</span> `Menghan`

- `git branch -r` <span style='color:#00CC66'>show remote-tracking branches</span>. 

  Remote branched are just like local branches, except they map to commits from somebody else’s repository. Remote branches are prefixed by the remote they belong to so that you don’t mix them up with local branches. 

  ```bash
  MY-Nuffield:Shared folder Menghan$ git branch -r
    origin/HEAD -> origin/master
    origin/Menghan
    origin/coauthor
    origin/master
  ```

  Q: What is `HEAD`?  
  A: `HEAD` stores the current commit hash ID, representing the currently checked-out-commit repository.  

  `origin/Menghan`, `origin/coauthor`, and `origin/master` are remote-tracking names Git created for human to read, Git itself uses big ugly hash IDs.

  ref: <https://stackoverflow.com/questions/74561949/why-does-head-show-up-in-git-branch-remote>

  ___

  Q: What is `origin`?  
  A: `origin` is the remote name, stored in your `.git/config`.

  ___

  

- `git branch -a` shows both local and remote branches.

  ```bash
  (base) menghan@Nord16 Shared folder % git branch -a
  * Menghan
    coauthor
    master
    remotes/origin/HEAD -> origin/master
    remotes/origin/Menghan
    remotes/origin/coauthor
    remotes/origin/master
  ```

  The first three are local branchesl the last four are remote branches.

- `git branch -M <main>`  <span style='color:#00CC66'>rename the current branch</span> to `main`.



`git push <remote> <remote-branch>` Push commits made on your local branch to a remote rep. 

-   E.g., `git push origin main` push your local changes to the remote repository on the  `main` branch. 
    -   Where git push initiates the push, `origin` refers to the remote counterpart of the project, and `main` is the remote branch name. This is common when you are the only contributor to your project, and you want to directly edit the default branch of your project with changes.

-   `<remote>` is the destination remote repo name of a push operation. This parameter can be either a URL or the name of a remote.
    -   When the command line does not specify where to push with the `<remote>` argument, `branch.*.remote` configuration for the current branch is consulted to determine where to push. If the configuration is missing, it defaults to *origin*.
-   `<remote-branch>` is a branch name in the remote repository where the changes should be pushed.

`git push origin <branch>` will push the current branch to the remote counterpart of that branch.

`git push origin` will push the current branch to the branch of the <span style='color:#00CC66'>matching name</span> in the remote repository (aka, “branch configured upstream”), if it exists. 

Otherwise, it will not push and notify that the current branch has no remote counterpart (error message: “\<branchname\> has no upstream branch”).

-   The default branch in your project is conventionally a branch named <span style='color:#00CC66'>"main"</span>. This branch is the version of the project that goes into production or the version from which you will create further branches to isolate changes, and merge back into the default branch.

-   If a project you are working on is older, the default branch might be named “master”, [which GitHub changed to remove references to slavery in conventional terminology.](https://www.zdnet.com/article/github-to-replace-master-with-alternative-term-to-avoid-slavery-references/) It’s important to check the name of the default branch.

<a id="git-push"></a>`git push origin` flags 

- `-u`, or `--set-upstream`: 

  `git push -u origin main` or `git push --set-upstream origin main`

  Creates a remote branch and sets it upstream of the current branch you are pushing. The relationship between the current branch and upstream branch is remembered, such that you will not have to continually connect the remote and local branches when pushing commits.

  -   It is recommended to use `-u` flag for the first push on a specific branch. When you use the `-u` flag, Git will create a link between your local branch and the remote branch. 
  -   Once a link btw your local and remote branches is created, you don't need to specify repo and branch in the future `pull` and `push`, Git will remember which remote branch corresponds to your local branch.
  
- `-f`, `--force`: 
  Pushes that would delete or overwrite existing code are usually blocked. With this command, pushes from your local repository would be forced onto the remote repository, potentially deleting or overwriting other commits! 

- `-d`, `--delete`:
  Deletes the remote branches listed. Eg, `git push origin --delete <branch name> `

- `--all`:
  Pushes all local branches to remote repository

Solve the `no upstream branch` error message: create a remote branch with the same name as the local branch and push changes to the remote branch (aka, “set upstream”).

-   `$ git push --set-upstream origin `. 







___

### Merge

`git merge <source-branch>` add the changes from `<source-branch>` into your current branch.  Use this command when you have finished building a feature in a separate branch, u.e.,  `<source-branch>`, and want to bring those changes into your current branch.

To do a merge (locally), `git checkout` the branch you want to merge *INTO*. Then type `git merge <branch>` where `<branch>` is the branch you want to merge *FROM*.

```bash
git checkout main # switch to the main branch
git merge new-feature # merge updates in new-feature to main
```

Now the `main` branch is in sync with `new-feature`.

<img src="https://drive.google.com/thumbnail?id=1-noV3Hg9FBnIGTTu-D_r6NONM7s93d5O&sz=w1000" alt="image-20230717104452192" style="display: block; margin-right: auto; margin-left: auto; zoom:50%;" />

When creating a merge commit Git will attempt to auto magically merge the separate histories for you. If Git encounters a piece of data that is changed in both histories it will be unable to automatically combine them. This scenario is a version control conflict and Git will need user intervention to continue. 

Resolve conflicts: `git mergetool` to check where the conflict occurs and why it occurs. 

- To see that which is the first edited text of the merge conflict in your file, search the file attached with conflict marker **`<<<<<<<`**. 

  - You can see the changes from the **HEAD** or base branch after the line **`<<<<<<< HEAD`** in your text editor. 

  - Next, you can see the divider like **`=======`**. It divides your changes from the changes in the other branch, **followed by `>>>>>>> BRANCH-NAME`**. In the above example, user1 wrote "<h1> Git is a version control</h1>" in the base or HEAD branch and user2 wrote "<h2> Git is a version control system </h2>".

    <img src="https://drive.google.com/thumbnail?id=1RzweNPfcdYvuGb9jp3MRJcCQXRJkkLB4&sz=w1000" alt="image-20230717112204536" style="zoom:50%;" />

  - Decide whether you want to keep only your branch's changes or the other branch's changes, or create a new change. Delete the conflict markers **`<<<<<<<`, `=======`, `>>>>>>>`** and create final changes you want to merge.

To accept the changes, use the `rebase` command. `git rebase --continue ` 







`git checkout <Menghan>` <span style='color:#00CC66'>switch to the branch</span> `Menghan`.

-   `git checkout .` will forgo all unstaged changes.
-   `git checkout -b <new-branch>` create a new branch named `new-branch` and then checked out.

`git branch (-m | -M) [<oldbranch>] <newbranch>`  	`<oldbranch>` will be <span style='color:#00CC66'>renamed</span> to `<newbranch>`. If `<oldbranch>` had a corresponding reflog, it is renamed to match `<newbranch>`, and a reflog entry is created to remember the branch renaming. If `<newbranch>` exists, `-M` must be used to force the rename to happen.

`git remote add <name> <url>` Add a remote named `<name>` for the repository at `<url>`. This is used to configure the remote repo, created a reference using the repo `<url>`.

-   `<name>` is a short remote name for your reference.

-   Now you can pass that remote name `<name>` to `git fetch <name>` to download the contents. 

Fetch a specific branch use `git fetch <remote repo name> <branch name>`. E.g., `git fetch origin test`.

Difference of `fetch` from `pull`: fetch does not merge; pull automatically merge remote to the current branch.



`git update-index --skip-worktree <file>`  causes the following error

> The following pathspecs didn't match any eligible path, but they do match index entries outside the current sparse checkout:

-   If what you want to do is to remove that `<file>` and index entry, unset the `skip-worktree` flag first, with `git update-index --no-skip-worktree "Shared folder.Rproj"`, and then `git rm` will work as expected.

-   If what you want to do is to just remove the index entry, you can do that directly, at the core-command level, `git update-index --force-remove "Shared folder.Rproj"`, or unset the flag as above then `git rm --cached` it.



`git push origin --delete Menghan` delete a remote branch.

`git push -u origin Menghan` push updates from `Menghan` (local)  to `origin` (remote) branch. `-u` is equivalent to `--set-upstream`.



Check **history** on Github

Code $\rightarrow$ History $\rightarrow$ click one commit, this will show your revision history.



Local repository content will change according to which branch you `checkout` in terminal. You make changes at your local branch, then you merge the updates to the `master` branch.

**If your branch is ahead of your master** — You get that message because you made changes in your local master and you didn't push them to remote. You need to navigate to `master` and merge the change from the local branch.

Use the following code to fix the ahead problem.

```bash
git add -A
git commit -m "My commit"
git checkout master # have to first checkout to master [receiving branch]
git merge Menghan # merge from Menghan --> master
git push -u origin master # push master changes from the current branch to the remote repo master branch.
```



**If your branch is behind your master**: navigate to the local branch and merge change from `master`.

```bash
git checkout master # you are switching your local branch to master
git pull # pull update from remote master
git checkout Menghan # switch back to your branch [receiving branch]
git merge master # from master --> Menghan
```

After merging it, check if there is a conflict or not.
If there is NO CONFLICT then:

```bash
(base) menghan@Nord16 Shared folder $ git push
Everything up-to-date
```

If nothing was pushed, it is likely Git did NOT push the currect branch. In this case, you can explicitly specify the branch you want to push as follows.

```bash
(base) menghan@Nord16 Shared folder $ git push origin Menghan
Total 0 (delta 0), reused 0 (delta 0), pack-reused 0
To https://github.com/my1396/Damage-Function.git
   39b1b00..6d5a038  Menghan -> Menghan
```



If there is a conflict then manually fix your file(s), then:

```bash
git add yourFile(s)
git commit -m 'updating my branch'
git push
```



___

#### Merge with GitHub Desktop

You want to merge `master` (source) into `Menghan` (target)

1. Navigate to the target repo `Menghan`

2. Click menu bar Branch → Merge into the current branch

   <img src="https://drive.google.com/thumbnail?id=1OyWEHuriIXN8DohshrZjcVdw44rm6luJ&sz=w1000" alt="Github merge" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />

3. In the "Merge into `Menghan`" dialog box, click the source repo `master`

   <img src="https://drive.google.com/thumbnail?id=1XsQUWcTfUIIAHf-hYZIPUWV2D2UiI6w8&sz=w1000" alt="Github merge" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />

4. Now `Menghan` is in sync with `master`. You can push your local changes to the remote repository, in the repository bar, click `Push origin`.

   <img src="https://drive.google.com/thumbnail?id=1Uvl8cHU71Bo5P9mhguv7hdUgruwnbLl3&sz=w1000" alt="Push Origin" style="display: block; margin-right: auto; margin-left: auto; zoom:70%;" />







___

## Best Practices for Team Collaboration

Your repository's `main` branch, which is regarded as the authoritative branch, is the only branch present by default.  Each co-author has their own branches where they make changes on. When they fill the changes are mature/final, they push to the `main` branch.

1. Open the repo: `cd Repo-Name` (e.g., `cd budget-frontend`)

2. Ensure you are on the main branch: `git checkout main`

3. Ensure you are up-to-date: `git pull`

   You definitely want to make sure your project is up to date before you push your changes. Otherwise, you risk breaking the build for others.

4. Create a new branch for your task: `git checkout -b Your-Branch` 

5. Code on `Your-Branch`

6. Add updates, commit, push to your remote branch `origin/Your-Branch`.

7. Merge with the `main` branch.



It's a good practice to run `git pull -r` before making any changes in your local repository.  

This makes sure you have got the latest code in case someone may have changed the remote repo. If there are changes on the remote branch that you haven't pulled, you might encounter conflicts when you try to push your changes later.

`-r`  or `--rebase` bases your changes from the current version from the repository.  If you started doing some development and then another developer made an unrelated change. 

`git rebase` would fetch the changes from the remote repository and put them <u>before/under</u> your local branch without creating a `merge` commit. It's particularly useful for <u>maintaining a linear project history</u>.

The following is a diagram of rebasing a `Feature` branch onto `main`. After rebasing, your `Feature` will be on the tip of `main` branch. This is like saying, "add my changes to what my team members have already done." 

By default, the `git pull` command performs a `merge`, but you can force it to integrate the remote branch with a rebase by passing it the `--rebase` option.

<figure style="text-align: center;"><img src="https://drive.google.com/thumbnail?id=1uwQgsDeDHVR1U7if64TC-GoQM7RcKCNY&sz=w1000" alt="Git Rebase" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" /><figcaption>Rebasing onto a remote branch. </figcaption>
</figure>

The major benefit of rebasing is that you get a much cleaner project history.  

- First, it <u>eliminates the unnecessary merge commits</u> required by `git merge`. 
- Second, as you can see in the above diagram, rebasing also results in a perfectly linear project history—you can follow the tip of `feature` all the way to the beginning of the project without any forks. 

___

Q: Are there any downsides/pitfalls with `rebase`?  
A: TL; DR: `git rebase` will rewrite the project history, make it impossible for Git and your teammates to track any follow-up commits added to the feature.

Long Answer: 

- Because a `rebase` moves commits (technically re-executes them), the commit date of all moved commits will be the time of the rebase and the **git history might look like it lost the initial commit time**.
  - So, if the exact date of a commit is needed in all tooling for some reason, then `merge` is the better option. But typically, a clean git history is much more useful than exact commit dates.
  - And the [author-date](https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-profile/managing-contribution-settings-on-your-profile/troubleshooting-commits-on-your-timeline#how-github-uses-the-git-author-date-and-commit-date) field will continue to hold the original commit date where needed.
- If the rebased branch has multiple commits that change the same line and that line was also changed in the base branch, you might need to solve merge conflicts for that same line multiple times, which you never need to do when merging. So, on average, there's more merge conflicts to solve.

___

The following shows a diagram of merging `main` to `Feature`.

<figure style="text-align: center;"><img src="https://drive.google.com/thumbnail?id=1LhnmrSQnnUgpQAd54tJlNcDS5NRqXxR7&sz=w1000" alt="Git Merge" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" /><figcaption>Merging  onto a remote branch. </figcaption>
</figure>



An example of when `git pull --rebase` could be useful: see [Stack Overflow Page](https://stackoverflow.com/a/28472221/10108921).



___

Q: When you use `git rebase` instead of `git merge`?  
A: See a full discussion [HERE](https://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge). But in short, 

- `merge` executes only **one** new commit. `rebase` typically executes **multiple** (number of commits in current branch).
- `merge` produces a **new** generated commit (the so called merge-commit). `rebase` only moves **existing** commits.

Q: What is a `merge`?  
A: A commit, that combines all changes of a different branch into the current.

Q: What is a `rebase`?  
A: Re-committing all commits of the current branch onto a different base commit.

Q: In which situations should we use a `merge`?  
A: Use merge whenever you want to add changes of a branched out branch **back** into the base branch.

Q: In which situations should we use a `rebase`?  
A: Use `rebase` whenever you want to add **changes of a base branch** back to a branched out branch.

Q: What does it mean by "`merge` creates *unnecessary merge commits*"?  
A:  If multiple merges were needed in a feature branch, then the feature branch might even hold more merge commits than actual commits! Below is an example of Git history when using `merge`:

<img src="https://drive.google.com/thumbnail?id=19_yD35xKrQxNCj3Wm4srQhPQGvZWI4-T&sz=w1000" alt="Git History–Merge" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />

Note the many commits starting with `Merge branch 'main' into ...`. They don't even exist if you rebase (there, you will only have pull request merge commits). Also many visual branch merge loops (`main` into `feature` into `main`).

Q: How does a Git history look like when using `rebase`?  
A: Much cleaner Git history with much less merge commits and no cluttered visual branch merge loops whatsoever. Looks like the following:

<img src="https://drive.google.com/thumbnail?id=1YIDkcu-uS-kkZyjEE4DKxbizM6TakGH5&sz=w1000" alt="Git History–Rebase" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />

___

## Squash Commits

"Commit early, commit often" is a popular mantra in software development when using Git. However, this can also lead to an overabundance of commits. 

This is where the importance of **squashing commits** comes into play. Commits can be combined into a single commits by squashing.

For instance, let’s say we work on a feature implementing a login form, and we create the following four commits:

<img src="https://media.datacamp.com/cms/google/ad_4nxepkfi_fk2rusomgitcluvwgugnbs2oza_bjuchte6ruirc16f0dazquz-u-orydd86wjtcvogcu65uaqp6io7v81rua-clwl8qhfghjbwkyv3rzn7_yhtdadxnrk_rnafzo6yvfl94rx6eocubjdj12bu4.png" alt="Git Commits" style="display: block; margin-right: auto; margin-left: auto; zoom:100%;" />

Once the feature is completed, for the overall project, these commits are too detailed. To ensure a clean history in the main branch, we squash these commits into a single commit:

<img src="https://media.datacamp.com/cms/google/ad_4nxdy6qebl2v13vucj5ujfcjlk8gzalksbgzcp-cwfss79wxphwz8wehu-jazlr1n1oozgy9o6cfric_v0h6p0ukcf6dagugsppct1igsaihqc_2wj7fpmm1ia_gq3afbnmawm34ums1zztvi5nea_hdq9cs.png" alt="Git Commits" style="display: block; margin-right: auto; margin-left: auto; zoom:100%;" />

The most common method to squash commits is using an i**nteractive rebase**. We start it using the command:

```bash
git rebase -i HEAD~<number_of_commits>
```

Replace `<number_of_commits>` with the number of commits we want to squash.

In our case, we have four commits, so the command is:

```bash
git rebase -i HEAD~4
```

Remember again that this is a rebasing command — every commit in the range `HEAD~4..HEAD` with a changed message *and all of its descendants* will be rewritten. 

❗️Don’t include any commit you’ve already pushed to a central server — doing so will confuse other developers by providing an alternate version of the same change.

Executing this command will open an interactive command-line editor that looks something like this:

<img src="https://media.datacamp.com/cms/google/ad_4nxfnhx6fbsnhqxse8v1-dmsxoot6xmhzsqfkgzc5eq7khh5w4sla3ltykvh1xq_sckuf4eoxniwwy3qkm8b9mmm1qpeuig-fjmstx3cap5abbmd11_fa8xwoxiyp8xk5gqkw98tsk_ltcr8oclr7dvy2p28p.png" alt="Git Commits" style="display: block; margin-right: auto; margin-left: auto; zoom:120%;" />

We see four commits that are listed in the opposite order. For each, we must decide which command to execute. We care about the `pick` (`p`) and `squash` (`s`) commands. 

To squash these four commits into a single commit, we can `pick` the first one and `squash` the remaining three.

After we have made the changes, the scirpt should look like:

<img src="https://media.datacamp.com/cms/google/ad_4nxc5xmf_a2xmkdnigtdculodeodfza_xymg7v8tdtemt8m7dh6rbkzcpizs4hmjrwmmwzlmnyg5us4w9xdm4fljw2huzgozf1pf2vpua5lchyllzpqq_y2timnisr2aldmvapcyqq7x8-f1phy4j4asz_wc.png" alt="Git Commits" style="display: block; margin-right: auto; margin-left: auto; zoom:120%;" />

When you save and exit the editor, Git will execute the script and open a new text editor. The editor will display a default message comprising the messages from the four commits we are squashing:

<img src="https://media.datacamp.com/cms/google/ad_4nxcy7ocys-cch426cwy9dmvlzei9kydusyp_wb_j822xsf_rh4yhvfu2aswmcln6ncxnr9qomtormn3gccjxd1ymwf4mgiig_wakluu2m0qesim62yave8vns_dlby14yzty3hr3fxquveqqlrvvkhxlbrc.png" alt="Git Commits" style="display: block; margin-right: auto; margin-left: auto; zoom:120%;" />

Enter the commit message to accurately reflect the changes implemented by these combined commits.

**Pusing Squashed Commits**

The command above will act on the local repository. To update the remote repository, we need to push our changes. However, because we changed the commit history, we need to force push using the `--force-with-lease` option:

```bash
git push --force-with-lease origin feature/login-form
```

This option ensures we only force push if the remote branch hasn't been updated since our last fetch or pull.



References:

<https://www.datacamp.com/tutorial/git-squash-commits>

<https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History>



___

## Gists

Q: When should I use a Gist instead of a full-fledged Git repo?  
A: Gist is meant for sharing code snippets. Usually, you either edit online directly or edit locally then copy-paste online, which will overwrite your whole history. Not ideal if you want to track exactly what you changed every time.

- Gist: If it's pieces of code designed to demonstrate a technique, teach a principle, or show off a solution, it goes in a Gist.
- GitHub: If it's actual code intended to be run, used as is, or forked as boilerplate I put it in a proper repository. For each project, you build a Git repository, where you can have multiple directories and organize different file types, track changes, etc.

___

Q: Should I clone Gist locally so that I manage it as a regular Git repo?  
A: No, I wouldn't do it. Each Gist will be one folder named by the Gist ID. It is not human readable. You can put it in a parent folder with a readable name, but imagine you have many Gists, then you have many (at least) two-level folders.

There is a workaround if you really need to edit locally. You can use the [GistPad](https://marketplace.visualstudio.com/items?itemName=vsls-contrib.gistfs) extension on VS Code. You can open, create, delete, fork, archive, and star gists/repositories, and then seamlessly begin editing files **as if they were local**, without ever cloning, pushing or pulling anything. 

___

Q: How about put all Gist in one regular repo?  
A: Not goog as you are putting lots of unrelated things together.

___

**GitHub Status Page**

Check [GitHub’s status page](https://www.githubstatus.com/) to see if there are any ongoing issues with GitHub Actions or infrastructure that might be causing delays.





___

<a id="github-education"></a>

## GitHub Education Benefits

GitHub Copilot is free to use for open source maintainers, teachers and students. We check eligibility monthly, per our policies.

See the following for various plans and pricing.

- [GitHub Copilot Plans](https://github.com/features/copilot/plans)
- [GitHub Docs: About individual GitHub Copilot plans and benefits](https://docs.github.com/en/copilot/concepts/billing/individual-plans)
- [Free access to Copilot Pro through GitHub Education](https://docs.github.com/en/copilot/how-tos/manage-your-account/get-free-access-to-copilot-pro)

--------------------------------------------------------------------------------

**Here is a summary of various plans**

- Free: 50 agent mode or chat requests per mont; 2,000 completions per month

  A "completion" is counted each time Copilot provides a code suggestion, regardless of whether it's accepted or not.

  So nearly every char I type is one completion (as the suggestions change while I type) – no wonder that the free credits are gone in no time.

  - Premium requests: up to 50 per month

- <span class="env-green">**Pro:**</span> **Unlimited** agent mode with GPT-4.1 and chats with GPT-4.1. Unlimited code completions.

  一般人最佳性价比之选。基本来说也够用了。偶尔需要大量使用时，可能额度不够。

  学生和教师凭借学校邮箱可以免费申请 Pro 版。[↩︎](https://docs.github.com/en/copilot/how-tos/manage-your-account/get-free-access-to-copilot-pro)
  
  - price: $10/mon.
  - Premium requests: up to <span class="env-green">300 per month</span>, with additional requests at $0.04/request.

- Pro+: \\$39/mon. 土豪专供，一般人还算了。按年付也要 \$390/yr.

  - 1,500 premium requests per month (**3x** the Pro plan); with the option to buy more (additional at \$0.04 USD each). 3倍的高级请求额度。

<div style="display: flex; justify-content: center; gap: 15px; overflow-x: auto;">
  <img src="{{site.baseurl}}/images/gh-copilot-1.png" alt="GitHub Copilot 1" style="width: 45%; height: auto;">
  <img src="{{site.baseurl}}/images/gh-copilot-2.png" alt="GitHub Copilot 2" style="width: 45%; height: auto;">
  <img src="{{site.baseurl}}/images/gh-copilot-3.png" alt="GitHub Copilot 3" style="width: 45%; height: auto;">
</div>



Q: What counts for [Premium requests](https://docs.github.com/en/copilot/concepts/billing/copilot-requests)?  \
A: Copilot Chat, *agent mode*, code review, and Copilot Extensions use premium requests, with usage varying by model. Purchase additional premium requests at $0.04/request.

Q: [How to see how many requests I have left?][copilot-usage] \
A: Click Copilot icon in the bottom left corner of VS Code

<img src="https://drive.google.com/thumbnail?id=14UZDd5XjUZpWOsb6YoUPGlbz7xi5fLfq&sz=w1000" alt="copilot usage" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />

You can view information about 

- features included in your plan, 
- your progress towards any limits on your plan, and
- the date your allowance resets.
  
  The allowance resets on the first day of each month.

[copilot-usage]: https://docs.github.com/en/copilot/how-tos/manage-and-track-spending/monitor-premium-requests "viewing premium requests usage"


--------------------------------------------------------------------------------


**Application**

After uploading proof, application was approved within five minutes.

Your academic benefits will become available within 72 hours of your verification. 

> The [waiting time](https://github.com/orgs/community/discussions/148395) may vary depending on different factors, such as the volume of requests; it usually takes a few days, but sometimes it can take a little longer, even a couple of weeks.

You will receive an email and the GitHub show "coupon applied." Click the link to accept the access.

> To redeem your Copilot Pro coupon, please sign up via this [link](https://github.com/github-copilot/free_signup).

After you click the link, the following page shows up.

<img src="https://drive.google.com/thumbnail?id=1Hyl9OVGbxhCevYLOaID0meKJTRgNFm8s&sz=w1000" alt="" style="display: block; margin-right: auto; margin-left: auto; zoom:60%;" />

If you have the GitHub Copilot extension already installed for your code editor and have it open, please **restart** your editor in order to access GitHub Copilot.

Valid for **two years** once approved. Expires in July 2027.

Once the benefits become available, you will be able to upgrade your organizations to GitHub Teams via your [GitHub Education dashboard](https://education.github.com/globalcampus/teacher).

**Benefits**

- [Free access to Copilot Pro through GitHub Education](https://docs.github.com/en/copilot/how-tos/manage-your-account/getting-free-access-to-copilot-pro-as-a-student-teacher-or-maintainer)

--------------------------------------------------------------------------------

### Use of GitHub Copilot

- GitHub Copilot is specifically designed for programming.

- Copilot for inline code completion: the gray text represents *ghost text* with Copilot’s suggestions.

  Accept suggestions with <kbd>Tab</kbd>.

- Copilot Chat
  - Type `/explain` and hit enter. Copilot will give you a detailed explanation of what’s happening in the code. 
  - Type your request and hit enter. Copilot will give you a plan, an updated code block, and a list of suggested changes. Hover over the code block, click the “Apply in Editor” button to accept the changes, and GitHub Copilot will make the updates for you.













