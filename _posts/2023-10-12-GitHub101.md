---
layout: post
title: GitHub Tutorial
tag: programming
update: 2023-10-12
---

$$
\newcommand{\indep}{\perp \!\!\! \perp}
$$

[Github Education Benefit](https://education.github.com/discount_requests/application)

- Apply for free [GitHub Team](https://docs.github.com/en/get-started/learning-about-github/githubs-plans), which allows unlimited users and private repositories. 



## [Push an existing repository](https://kbroman.org/github_tutorial/pages/init.html)

1. Initialize an existing project to start tracking with `git`.

   - Go into the directory containing the project.

   - Type `git init`.

   - Type `git add .` to add all of the relevant files. This step is called "staging."
     - You’ll probably want to create a `.gitignore` file right away, to indicate all of the files you don’t want to track. Use `git add .gitignore`, too.
     
   - Type `git commit -m 'commit message'`.

     `commit` records changes to the local repository.

     git generally requires a non-empty commit message.

     

2. Create a online repo and connect it to your local git project.

   <ol type="a">
   <li> Go to <a href="https://github.com/">GitHub</a>, click the <a href="https://github.com/new">new repository</a> button in the top-right. You’ll have an option there to initialize the repository with a README file.
   <img src="https://drive.google.com/thumbnail?id=1N1bOGsiKoVIp312snyOJg-3UJKWwgYzV&sz=w1000" alt="new GitHub repo" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />
   </li>
   <li> Click the “Create repository” button. </li>
   <li> Connect your local repo to the remote repo you just created using the following cmds. 
     <pre><code># add repo name "origin" to the remote repo at the URL
   $ git remote add origin https://github.com/my1396/Damage-Function.git
   # rename the "current" local branch to main
   $ git branch -M main 
   # push update from the current local branch (main) to remote (origin) repo's main branch; -u is a shortname for --set-upstream; first parameter is upstream then 2nd parameter is local repo
   # local and remote branch names should be matching
   $ git push -u origin main </code></pre>
   Note that <code>main</code> can be replaced by <code>master</code> for older repositories. 
   </li>
   <li> Then use GitHub Desktop to manage the repo committing, syncing, ..., later on. </li>
   </ol>



___

Q: Is it worth using GitHub Desktop?  
A: Yes and no. It is useful if you just want to do basic management of your repositories. There are many things you cannot do with GitHub Desktop, e.g., you cannot rename a file. You need to do it with commond line or using online GitHub. Github desktop hides a lot of the details of handling git, making it difficult to debug. Additionally, git integration into almost any IDE is available and possibly more powerful, such as VS code git extension allows to rename a file directly. 

___

**Troubleshooting**

Error: `git pull origin main` returns 

> You have divergent branches and need to specify how to reconcile them.  
>You can do so by running one of the following commands sometime before your next pull:
> 
>`git config pull.rebase false # merge`
> 
>`git config pull.rebase true  # rebase`
> 
>`git config pull.ff only      # fast-forward only`
> 
>fatal: Need to specify how to reconcile divergent branches.

"Divergent branches" 常出现于 remote repo 初始化时不是空的。这种情况下，需要先 `git pull` 合并 remote 和 local，然后再 `git push`。

Fix: run `git pull origin main --rebase`.





___

## Github common commands

**Documentation**:  <https://git-scm.com/docs/git-push>

You can change the language using the top-right language tab.

<img src="https://drive.google.com/thumbnail?id=1W6Dx5k4mWS9Sl-cvYDJYfxcCV_H-RGne&sz=w1000" alt="Git References" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />

中文：<https://git-scm.com/book/zh/v2/Git-分支-分支简介>



Q: How to view the commit history?  
A: Use `git log`. Executing the command would display:

<img src="https://media.datacamp.com/cms/google/ad_4nxehoftxdd-9sh1nrxsjhvufwverjojcgygg-6ifk-hwq4ql0uq8yt6hoqefka5rmajoeypra6by2byeha6slco8abv1k5t7rqnvxx6s-9e1ww3xw-yrcbpc66i6pf2aqbmryswkbojbb4o6y1ouwgt3pv8.png" alt="Git Commits" style="display: block; margin-right: auto; margin-left: auto; zoom:100%;" />

To navigate the list of commits, use the up and down arrow keys. To exit, press `q`.



Q: Should I push every single commit?   
A: Committing to your local repository you are basically saying "I trust this code." When you feel you want your teammates to see your changes, you `push` to remote. If you collaborate with others, pushing more frequently would have a lower risk of conflict.



Q: What are local and remote repositories?   
A: 

- Local repositories are about tracking your changes to protect the work you do. 
- Remote repositories are for distributing the work to all your teammates and tracking everyone's changes. 



### Git Remote Configurations

`git remote` Creating and modifying git remote configurations

Commonly used `git remote` subcommands:

- Create a **new** connection to a remote repository.

  ```bash
  git remote add <name> <url>
  # Example: add repo name "origin" to the remote repo at the URL
  git remote add origin https://github.com/my1396/Damage-Function.git
  ```

  After adding a remote, you’ll be able to use `＜name＞` as a convenient shortcut for `＜url＞` in other Git commands.

- **Remove** the connection to the remote repository called `＜name＞`.

  ```bash
  git remote rm <name>
  ```

- **Rename** a remote connection from `＜old-name＞` to `＜new-name＞`.

  ```bash
  git remote rename <old-name> <new-name>
  ```

- Show your remotes

  `git remote` without any flags will list previously stored remote connections

  ```bash
  $ git remote
  origin
  ```
  
  `git remote [-v | --verbose]` show remote URL after name. `-v` stands for "verbose."

  ```bash
  $ git remote -v
  origin	https://github.com/my1396/Econ-Study.git (fetch)
  origin	https://github.com/my1396/Econ-Study.git (push)
  ```
  
  `git remote show <remote-repo-name>` give detailed output on the configuration of a remote given by  `<remote-repo-name>`.
  
  ```bash
  $ git remote show origin  
  * remote origin
    Fetch URL: https://github.com/my1396/Econ-Study.git
    Push  URL: https://github.com/my1396/Econ-Study.git
    HEAD branch: main
    Remote branch:
      main tracked
    Local branch configured for 'git pull':
      main merges with remote main
    Local ref configured for 'git push':
      main pushes to main (up to date)
  ```
  
  



___

**Repo's <span style='color:#00CC66'>configuration file</span>** 

- Path: `./.git/config`

  `git remote add` command will modify the configuration file.

  You can directly edit the `./.git/config` file with a text editor.

- Looks like the following

  ```bash
  [core]
  	repositoryformatversion = 0
  	filemode = true
  	bare = false
  	logallrefupdates = true
  	ignorecase = true
  	precomposeunicode = true
  [remote "origin"]
  	url = https://github.com/my1396/R-Notes.git
  	fetch = +refs/heads/*:refs/remotes/origin/*
  [pull]
  	ff = only
  [branch "main"]
  	remote = origin
  	merge = refs/heads/main
  [lfs]
  	repositoryformatversion = 0
  ```

  - `url` tells `git fetch origin` where to fetch the repository
  - `fetch` refspec tells `git fetch origin` which names to create or update in your own repository.

___



`git rev-parse --is-inside-work-tree` 	check is a folder is a git repository. Which will print 'true' to STDOUT if you are in a git repos working tree.

-   Note that it still returns output to STDERR if you are outside of a git repo (and does not print 'false').



___



`git fetch`:  downloads commits, files from a remote repository into your local repo, but it doesn't integrate any of this new data into your working files. 

`git pull <remote>`: `fetch` + `merge`.  Directly **integrates** changes into your current working copy files. This command does two main things: 

- first, it executes `git fetch` which contacts the remote repository and pulls down any data it doesn't already have, including updates to branches and tags. 
- Second, it merges one of these branches (usually the corresponding branch) into your current branch, combining the remote changes with your local ones. 

Q: Why `git fetch` is safer?  
A:  `git fetch` will download the remote content and not alter the state of the local repository. Alternatively, `git pull` will download remote content and immediately attempt to change the local state to match that content. This may unintentionally cause the local repository to get in a conflicted state.

<u>Common options</u> of `git pull`:

`git pull <remote>`  Fetch the specified remote’s copy of the current branch and immediately merge it into the local copy.

`git pull --rebase <remote>`  fetches the remote content but does not create a new merge commit, Instead of using `git merge` to integrate the remote branch with the local one, use `git rebase`. 

Case scenario: you are working on `new-feature` and before you push, you `pull` the remote repo to make sure you have the latest code in case some has made changes.

```bash
# fectch + merge
git checkout new-feature
git fetch origin
git merge origin

# pull
git checkout new-feature
git pull --rebase origin # append your change to the main
```



___



`git push [options] <remote-repo> <remote-branch>`: update remote repository with local changes you committed. See [HERE](#git-push) for command arguments.

- `<remote-repo>`:     The <u>remote repository</u> that is the destination of a push operation. This parameter can be either a URL or the name of a remote.
- `<remote-branch>`:           The name of the <u>branch in the remote repository</u> where the changes should be pushed. 

You often encounter <span style='color:#00CC66'>`git push origin main`</span> when working with git. Why `origin` and `main`?

- `origin` is the <u>default name given to the remote repository</u> when you clone a repository. 

  It acts as a shorthand for the remote repository’s URL (e.g., a repository hosted on GitHub, GitLab, or another Git server).

  `origin` specifies the remote repository that should receive the changes.

- `main` is the name of a branch in your Git repository. 

  By convention, `main` often serves as the default branch for a repository. It typically contains the latest stable version of the code.

  The branch name specifies which branch in the remote repository should receive the changes. Without specifying the branch, Git might use a default branch or require additional configuration.



___

### Rename File

**<span style='color:#00CC66'>Rename</span> a file, a directory, or a symlink**

`git mv [<options>] <source> <destination> ` Move or rename a file, directory, or symlink.

- `<source>` 	which must exist and be either a file, symlink or directory
- `<destination>`  is the new file name, symlink or directory

Basic Syntax

To move or rename a file using git mv, simply specify the existing and new paths of the file after the command:

```bash
git mv ./old_directory/old_file.ext ./new_directory/new_file.ext
```

<u>Renaming or moving files</u> with `git mv` <u>preserves the file’s history</u> and is especially useful in collaborative development to maintain a clear and organized project structure.

- If you do the renaming manually, the change will be recorded as delete and add a new file, the changes of the file won't be preserved.

```bash
# if the file you plan to rename is in your current directory
# use file name directly
git mv gfg1.py gfg2.py 
```

<img src="https://drive.google.com/thumbnail?id=1CgtlOAOMsDlELGbSMZDg-FxquXAGkDww&sz=w1000" alt="Git mv" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />

**Troubleshooting**

> fatal: not under version control, source=_posts/2023-10-12-Bibli.md, destination=_posts/2023-10-12-Jekyll-Bibli.md

Cause: The error happens because the parent folder has special character (`_posts/`). 

Fix: Enclose file names with quotes.

```bash
git mv "_posts/2023-10-12-Bibli.md" "_posts/2023-10-12-Jekyll-Bibli.md"
```



___

`git rm` The primary function of `git rm` is to remove tracked files from the Git index. Additionally, `git rm` can be used to remove files from both the staging index and the working directory.

-   `-r` the option is shorthand for '<u>r</u>ecursive'. When operating in recursive mode `git rm` will remove a target directory and all the contents of that directory.
-   `--cached` The `--` separator option is used to explicitly distinguish between a list of file names and the arguments being passed to `git rm`. This is useful if some of the file names have syntax that might be mistaken for other options.
    -   The cached option specifies that the removal should happen only on the staging index. Working directory files will be left alone.

___

Q: Do I need to quote file names?  
A: Depends on your shell, has nothing to do with `git`.

Most shells "tokenize" the command line -- that is, split it into a sequence of discrete elements -- using whitespace. So, for example

```bash
rm one file
```

will attempt to remove a file named `one` and a file named `file`, whereas

```bash
rm 'one file'
```

will attempt to remove a single file named `one file`. 

The principle is

- it does NOT matter whether you quote when your file name/path does NOT contain spaces.
- when you write `commit` messages, usually write inside quotes as it is common to have spaces inside your message.



___



Git doesn't track directories, so it won't remove ones that become empty as a result of a merge or other change. However, you can use `git clean -fd` to remove untracked directories (the `-fd` flag means *f*orce removal of untracked files and directories).

`git restore .`   discards all *unstaged* files in current working directory use.

For one specific file use: `git restore <path/to/file/to/revert>`





___

### gitignore

`foo/` will match a directory `foo` and paths underneath it. `foo` and `/foo` have the same effect. The leading slash doesn't matter.

`*` matches anything (zero, one, or more characters) except a slash `/`.

`?` matches one single character except a slash `/`.

A line starting with `#` serves as a comment. 
To match files that begin with a hash, put a backslash ("`\`", escape character) in front of the first hash.



**Delete a file in `.gitignore` after you have already added it to the repo.**

How to make Git forget about a file that was tracked, but is now in `.gitignore`?

`.gitignore` is only for untracked files.

```bash
# This removes all files from the repository and adds them back (this time respecting the rules in your .gitignore).
git rm -rf --cached "Shared folder.Rproj"
git add .
git commit -m "clear cache"
git push
```

If you make changes to your repository, the workflow is `add` $\rightarrow$ `commit` $\rightarrow$ `push.`



**Undo local changes**

Until you push your changes to a remote repository, changes you make in Git are only in your local development environment.

When you make a change, but have not yet staged it, you can undo your work.

```bash
git reset --hard
```

Undo staged local changes:

```bash
git reset --hard
```

Undo committed local changes. When you commit to your local repository (`git commit`), Git records your changes. Because you did not push to a remote repository yet, your changes are not public (or shared with other developers). At this point, you can undo your changes.



___

## Failure When Push Large Files

Github Error: 

- [RPC failed; HTTP 400 curl 22 The requested URL returned error: 400 Bad Request](https://stackoverflow.com/questions/62753648/rpc-failed-http-400-curl-22-the-requested-url-returned-error-400-bad-request)

- RPC failed; curl 55 Failed sending data to the peer send-pack: unexpected disconnect while reading sideband packet.

This is an HTTP buffer issue. Happens when you are pushing a large amount of data.

**Fix**: 

1. Increase the buffer will solve the issue. [Easiest solution] Or, 
2. you could push by small batches of changes. Or, 
3. use Git Large File Storage. 

```bash
git config http.postBuffer 524288000
git pull && git push
```

Q: what does `http.postBuffer` do?

A: This option changes the size of the buffer that Git uses when pushing data to a remote over HTTP or HTTPS.

> The default of httpBuffer size is set to 1MB for https. Please note the only acceptable values are 524288000 (500mb), 1048576000 (1 GB) and 2147483648 (2 GB). Anything above it, is considered out of range.

`git config http.postBuffer 524288000` will set the httpBuffer size to 500 MB.



To remove the file that you have already committed, you are going to need to reset your HEAD to the commit before the one that contains your file. Make sure you are performing a *soft reset.*

```
git reset --soft HEAD~1
```

1 is the number of commits you need to move back, can be greater than 1.



___

### Git Large File Storage

``` ./install.sh.``` install Git Large File Storage from source.

Go to the Git repository where you want to use Git LFS, select the file types you'd like Git LFS to manage (or directly edit your .gitattributes). You can configure additional file extensions at anytime.

```bash
git lfs track "*.psd"
git lfs track "*.png"
```

Now make sure .gitattributes is tracked. Your tracked files’ details are saved inside a `.gitattributes`so make sure to add `.gitattributes` to persist tracking when other users clone the project.

```bash
git add .gitattributes
```

You should then be able to safely add, commit and push!

```bash
git add file.png
git commit -m "Add design file"
git push origin main
```



___

## Branch management

Q: What are different branches for?  
A: There are different types of branches, including the main branch (usually called "master" or "main"), feature branches, release branches, and hotfix branches. Each branch serves a specific purpose and helps developers manage their codebase better.

___

Q: Can I clone a specific branch?  
A: Yes.  Run the following code

```bash
git clone --branch <branchname> --single-branch <remote-repo-url>
```

`--branch` (two hyphens) can be replaced by `-b` (one hyphen).

Cloning a specific branch in Git is a useful feature that allows developers to work on specific features or bug fixes without cloning the entire repository.

___

But you may want to clone all branches first, and then work on your own branch. When you finish, you can merge your updates into the `main` branch. This makes it easier to compare differences and make sure your branch is in sync with with the `main` branch.

To this end, you need to run

```bash
// this will clone all branches
git clone <remote-repo-url>
```

Then you could `checkout` to one specific branch to work.

These could be achieved by one combined command too with the argument `--branch <branchname>`.

```bash
// clone all branch then switch to <branchname>
git clone --branch <branchname> <remote-repo-url>
// or using -b alias for --branch
git clone -b <branchname> <remote-repo-url>
```

A downside of `clone` the whole repository is that you will fetch all files from each branch. You might not want this if the repository has a large history.



___

### Collaborations

You can also open Pull Requests between separate branches on GitHub. This often presents a good way for <span style='color:#00CC66'>collaborating</span> with people who have access to the same repository. You don't want to all be pushing to the `main` branch all the time. Instead, each person can create their own branch, work separately, and then open a pull request to merge that branch into `main`.

If you create a local branch in your repo, you can push it to GitHub as follows:

First, make sure that you are *on* the branch that you want to push:

```bash
$ git branch
```

Then run 

```bash
# -u option will set up a link between local and remote upstream branches
# -u is used when you have your initial push of your update
$ git push -u origin <branch-name>
```

to push the current local (active) branch to the remote branch `<branch-name>`. 

`-u` is a shortname for `--set-upstream`; 

- the 1st parameter is the upstream repo, 
- the 2nd parameter is the local repo.

After establishing the upstream at the initial push, you can use `git push` with no argument for later updates.

Note that branch names should be matching between local and remote repositories. When you run `git push origin main`, Git pushes the commits from your local `main` branch to the corresponding `main` branch on the remote repository.



- `git branch` with no argument (or with `--list`) will print a list of branches linked to the current repo. 

  Could be used to check which branch I am currently on. Your current branch (i.e., the branch that `HEAD` points to) is prefixed by `*`  and highlighted in green.

  ```bash
  (base) menghan@Nord16 Shared folder $ git branch
  * Menghan
    coauthor
    master
  ```

  

- `git branch Menghan` <span style='color:#00CC66'>create a branch</span> called `Menghan`

  ```bash
  // create a branch
  $ git branch <branch-name>
  // switch to the branch
  $ git checkout <branch-name>
  ```

  Or, there is a combined command first creating a branch then switching to it

  ```bash
  // create a branch and switch to the branch
  $ git checkout -b <branch-name>
  ```

  Now we want to add this branch remotely. All we have to do is push it to our Git provider such as GitHub using the command below:

  ```bash
  $ git push -u origin <branch-name>
  ```

  

- `git branch -d Menghan` <span style='color:#00CC66'>delete the local branch</span> `Menghan`

- `git branch -r` <span style='color:#00CC66'>show remote-tracking branches</span>. 

  Remote branched are just like local branches, except they map to commits from somebody else’s repository. Remote branches are prefixed by the remote they belong to so that you don’t mix them up with local branches. 

  ```bash
  MY-Nuffield:Shared folder Menghan$ git branch -r
    origin/HEAD -> origin/master
    origin/Menghan
    origin/coauthor
    origin/master
  ```

  Q: What is `HEAD`?  
  A: `HEAD` stores the current commit hash ID, representing the currently checked-out-commit repository.  

  `origin/Menghan`, `origin/coauthor`, and `origin/master` are remote-tracking names Git created for human to read, Git itself uses big ugly hash IDs.

  ref: <https://stackoverflow.com/questions/74561949/why-does-head-show-up-in-git-branch-remote>

  ___

  Q: What is `origin`?  
  A: `origin` is the remote name, stored in your `.git/config`.

  ___

  

- `git branch -a` shows both local and remote branches.

  ```bash
  (base) menghan@Nord16 Shared folder % git branch -a
  * Menghan
    coauthor
    master
    remotes/origin/HEAD -> origin/master
    remotes/origin/Menghan
    remotes/origin/coauthor
    remotes/origin/master
  ```

  The first three are local branchesl the last four are remote branches.

- `git branch -M <main>`  <span style='color:#00CC66'>rename the current branch</span> to `main`.



`git push <remote> <remote-branch>` Push commits made on your local branch to a remote rep. 

-   E.g., `git push origin main` push your local changes to the remote repository on the  `main` branch. 
    -   Where git push initiates the push, `origin` refers to the remote counterpart of the project, and `main` is the remote branch name. This is common when you are the only contributor to your project, and you want to directly edit the default branch of your project with changes.

-   `<remote>` is the destination remote repo name of a push operation. This parameter can be either a URL or the name of a remote.
    -   When the command line does not specify where to push with the `<remote>` argument, `branch.*.remote` configuration for the current branch is consulted to determine where to push. If the configuration is missing, it defaults to *origin*.
-   `<remote-branch>` is a branch name in the remote repository where the changes should be pushed.

`git push origin <branch>` will push the current branch to the remote counterpart of that branch.

`git push origin` will push the current branch to the branch of the <span style='color:#00CC66'>matching name</span> in the remote repository (aka, “branch configured upstream”), if it exists. 

Otherwise, it will not push and notify that the current branch has no remote counterpart (error message: “\<branchname\> has no upstream branch”).

-   The default branch in your project is conventionally a branch named <span style='color:#00CC66'>"main"</span>. This branch is the version of the project that goes into production or the version from which you will create further branches to isolate changes, and merge back into the default branch.

-   If a project you are working on is older, the default branch might be named “master”, [which GitHub changed to remove references to slavery in conventional terminology.](https://www.zdnet.com/article/github-to-replace-master-with-alternative-term-to-avoid-slavery-references/) It’s important to check the name of the default branch.

<a id="git-push"></a>`git push origin` flags 

- `-u`, or `--set-upstream`: 

  `git push -u origin main` or `git push --set-upstream origin main`

  Creates a remote branch and sets it upstream of the current branch you are pushing. The relationship between the current branch and upstream branch is remembered, such that you will not have to continually connect the remote and local branches when pushing commits.

  -   It is recommended to use `-u` flag for the first push on a specific branch. When you use the `-u` flag, Git will create a link between your local branch and the remote branch. 
  -   Once a link btw your local and remote branches is created, you don't need to specify repo and branch in the future `pull` and `push`, Git will remember which remote branch corresponds to your local branch.
  
- `-f`, `--force`: 
  Pushes that would delete or overwrite existing code are usually blocked. With this command, pushes from your local repository would be forced onto the remote repository, potentially deleting or overwriting other commits! 

- `-d`, `--delete`:
  Deletes the remote branches listed. Eg, `git push origin --delete <branch name> `

- `--all`:
  Pushes all local branches to remote repository

Solve the `no upstream branch` error message: create a remote branch with the same name as the local branch and push changes to the remote branch (aka, “set upstream”).

-   `$ git push --set-upstream origin `. 







___

### Merge

`git merge <source-branch>` add the changes from `<source-branch>` into your current branch.  Use this command when you have finished building a feature in a separate branch, u.e.,  `<source-branch>`, and want to bring those changes into your current branch.

To do a merge (locally), `git checkout` the branch you want to merge *INTO*. Then type `git merge <branch>` where `<branch>` is the branch you want to merge *FROM*.

```bash
git checkout main # switch to the main branch
git merge new-feature # merge updates in new-feature to main
```

Now the `main` branch is in sync with `new-feature`.

<img src="https://drive.google.com/thumbnail?id=1-noV3Hg9FBnIGTTu-D_r6NONM7s93d5O&sz=w1000" alt="image-20230717104452192" style="display: block; margin-right: auto; margin-left: auto; zoom:50%;" />

When creating a merge commit Git will attempt to auto magically merge the separate histories for you. If Git encounters a piece of data that is changed in both histories it will be unable to automatically combine them. This scenario is a version control conflict and Git will need user intervention to continue. 

Resolve conflicts: `git mergetool` to check where the conflict occurs and why it occurs. 

- To see that which is the first edited text of the merge conflict in your file, search the file attached with conflict marker **`<<<<<<<`**. 

  - You can see the changes from the **HEAD** or base branch after the line **`<<<<<<< HEAD`** in your text editor. 

  - Next, you can see the divider like **`=======`**. It divides your changes from the changes in the other branch, **followed by `>>>>>>> BRANCH-NAME`**. In the above example, user1 wrote "<h1> Git is a version control</h1>" in the base or HEAD branch and user2 wrote "<h2> Git is a version control system </h2>".

    <img src="https://drive.google.com/thumbnail?id=1RzweNPfcdYvuGb9jp3MRJcCQXRJkkLB4&sz=w1000" alt="image-20230717112204536" style="zoom:50%;" />

  - Decide whether you want to keep only your branch's changes or the other branch's changes, or create a new change. Delete the conflict markers **`<<<<<<<`, `=======`, `>>>>>>>`** and create final changes you want to merge.

To accept the changes, use the `rebase` command. `git rebase --continue ` 







`git checkout <Menghan>` <span style='color:#00CC66'>switch to the branch</span> `Menghan`.

-   `git checkout .` will forgo all unstaged changes.
-   `git checkout -b <new-branch>` create a new branch named `new-branch` and then checked out.

`git branch (-m | -M) [<oldbranch>] <newbranch>`  	`<oldbranch>` will be <span style='color:#00CC66'>renamed</span> to `<newbranch>`. If `<oldbranch>` had a corresponding reflog, it is renamed to match `<newbranch>`, and a reflog entry is created to remember the branch renaming. If `<newbranch>` exists, `-M` must be used to force the rename to happen.

`git remote add <name> <url>` Add a remote named `<name>` for the repository at `<url>`. This is used to configure the remote repo, created a reference using the repo `<url>`.

-   `<name>` is a short remote name for your reference.

-   Now you can pass that remote name `<name>` to `git fetch <name>` to download the contents. 

Fetch a specific branch use `git fetch <remote repo name> <branch name>`. E.g., `git fetch origin test`.

Difference of `fetch` from `pull`: fetch does not merge; pull automatically merge remote to the current branch.



`git update-index --skip-worktree <file>`  causes the following error

> The following pathspecs didn't match any eligible path, but they do match index entries outside the current sparse checkout:

-   If what you want to do is to remove that `<file>` and index entry, unset the `skip-worktree` flag first, with `git update-index --no-skip-worktree "Shared folder.Rproj"`, and then `git rm` will work as expected.

-   If what you want to do is to just remove the index entry, you can do that directly, at the core-command level, `git update-index --force-remove "Shared folder.Rproj"`, or unset the flag as above then `git rm --cached` it.



`git push origin --delete Menghan` delete a remote branch.

`git push -u origin Menghan` push updates from `Menghan` (local)  to `origin` (remote) branch. `-u` is equivalent to `--set-upstream`.



Check **history** on Github

Code $\rightarrow$ History $\rightarrow$ click one commit, this will show your revision history.



Local repository content will change according to which branch you `checkout` in terminal. You make changes at your local branch, then you merge the updates to the `master` branch.

**If your branch is ahead of your master** — You get that message because you made changes in your local master and you didn't push them to remote. You need to navigate to `master` and merge the change from the local branch.

Use the following code to fix the ahead problem.

```bash
git add -A
git commit -m "My commit"
git checkout master # have to first checkout to master [receiving branch]
git merge Menghan # merge from Menghan --> master
git push -u origin master # push master changes from the current branch to the remote repo master branch.
```



**If your branch is behind your master**: navigate to the local branch and merge change from `master`.

```bash
git checkout master # you are switching your local branch to master
git pull # pull update from remote master
git checkout Menghan # switch back to your branch [receiving branch]
git merge master # from master --> Menghan
```

After merging it, check if there is a conflict or not.
If there is NO CONFLICT then:

```bash
(base) menghan@Nord16 Shared folder $ git push
Everything up-to-date
```

If nothing was pushed, it is likely Git did NOT push the currect branch. In this case, you can explicitly specify the branch you want to push as follows.

```bash
(base) menghan@Nord16 Shared folder $ git push origin Menghan
Total 0 (delta 0), reused 0 (delta 0), pack-reused 0
To https://github.com/my1396/Damage-Function.git
   39b1b00..6d5a038  Menghan -> Menghan
```



If there is a conflict then manually fix your file(s), then:

```bash
git add yourFile(s)
git commit -m 'updating my branch'
git push
```



___

#### Merge with GitHub Desktop

You want to merge `master` (source) into `Menghan` (target)

1. Navigate to the target repo `Menghan`

2. Click menu bar Branch → Merge into the current branch

   <img src="https://drive.google.com/thumbnail?id=1OyWEHuriIXN8DohshrZjcVdw44rm6luJ&sz=w1000" alt="Github merge" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />

3. In the "Merge into `Menghan`" dialog box, click the source repo `master`

   <img src="https://drive.google.com/thumbnail?id=1XsQUWcTfUIIAHf-hYZIPUWV2D2UiI6w8&sz=w1000" alt="Github merge" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />

4. Now `Menghan` is in sync with `master`. You can push your local changes to the remote repository, in the repository bar, click `Push origin`.

   <img src="https://drive.google.com/thumbnail?id=1Uvl8cHU71Bo5P9mhguv7hdUgruwnbLl3&sz=w1000" alt="Push Origin" style="display: block; margin-right: auto; margin-left: auto; zoom:70%;" />







___

## Best Practices for Team Collaboration

Your repository's `main` branch, which is regarded as the authoritative branch, is the only branch present by default.  Each co-author has their own branches where they make changes on. When they fill the changes are mature/final, they push to the `main` branch.

1. Open the repo: `cd Repo-Name` (e.g., `cd budget-frontend`)

2. Ensure you are on the main branch: `git checkout main`

3. Ensure you are up-to-date: `git pull`

   You definitely want to make sure your project is up to date before you push your changes. Otherwise, you risk breaking the build for others.

4. Create a new branch for your task: `git checkout -b Your-Branch` 

5. Code on `Your-Branch`

6. Add updates, commit, push to your remote branch `origin/Your-Branch`.

7. Merge with the `main` branch.



It's a good practice to run `git pull -r` before making any changes in your local repository.  

This makes sure you have got the latest code in case someone may have changed the remote repo. If there are changes on the remote branch that you haven't pulled, you might encounter conflicts when you try to push your changes later.

`-r`  or `--rebase` bases your changes from the current version from the repository.  If you started doing some development and then another developer made an unrelated change. 

`git rebase` would fetch the changes from the remote repository and put them <u>before/under</u> your local branch without creating a `merge` commit. It's particularly useful for <u>maintaining a linear project history</u>.

The following is a diagram of rebasing a `Feature` branch onto `main`. After rebasing, your `Feature` will be on the tip of `main` branch. This is like saying, "add my changes to what my team members have already done." 

By default, the `git pull` command performs a `merge`, but you can force it to integrate the remote branch with a rebase by passing it the `--rebase` option.

<figure style="text-align: center;"><img src="https://drive.google.com/thumbnail?id=1uwQgsDeDHVR1U7if64TC-GoQM7RcKCNY&sz=w1000" alt="Git Rebase" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" /><figcaption>Rebasing onto a remote branch. </figcaption>
</figure>

The major benefit of rebasing is that you get a much cleaner project history.  

- First, it <u>eliminates the unnecessary merge commits</u> required by `git merge`. 
- Second, as you can see in the above diagram, rebasing also results in a perfectly linear project history—you can follow the tip of `feature` all the way to the beginning of the project without any forks. 

___

Q: Are there any downsides/pitfalls with `rebase`?  
A: TL; DR: `git rebase` will rewrite the project history, make it impossible for Git and your teammates to track any follow-up commits added to the feature.

Long Answer: 

- Because a `rebase` moves commits (technically re-executes them), the commit date of all moved commits will be the time of the rebase and the **git history might look like it lost the initial commit time**.
  - So, if the exact date of a commit is needed in all tooling for some reason, then `merge` is the better option. But typically, a clean git history is much more useful than exact commit dates.
  - And the [author-date](https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-profile/managing-contribution-settings-on-your-profile/troubleshooting-commits-on-your-timeline#how-github-uses-the-git-author-date-and-commit-date) field will continue to hold the original commit date where needed.
- If the rebased branch has multiple commits that change the same line and that line was also changed in the base branch, you might need to solve merge conflicts for that same line multiple times, which you never need to do when merging. So, on average, there's more merge conflicts to solve.

___

The following shows a diagram of merging `main` to `Feature`.

<figure style="text-align: center;"><img src="https://drive.google.com/thumbnail?id=1LhnmrSQnnUgpQAd54tJlNcDS5NRqXxR7&sz=w1000" alt="Git Merge" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" /><figcaption>Merging  onto a remote branch. </figcaption>
</figure>



An example of when `git pull --rebase` could be useful: see [Stack Overflow Page](https://stackoverflow.com/a/28472221/10108921).



___

Q: When you use `git rebase` instead of `git merge`?  
A: See a full discussion [HERE](https://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge). But in short, 

- `merge` executes only **one** new commit. `rebase` typically executes **multiple** (number of commits in current branch).
- `merge` produces a **new** generated commit (the so called merge-commit). `rebase` only moves **existing** commits.

Q: What is a `merge`?  
A: A commit, that combines all changes of a different branch into the current.

Q: What is a `rebase`?  
A: Re-comitting all commits of the current branch onto a different base commit.

Q: In which situations should we use a `merge`?  
A: Use merge whenever you want to add changes of a branched out branch **back** into the base branch.

Q: In which situations should we use a `rebase`?  
A: Use `rebase` whenever you want to add **changes of a base branch** back to a branched out branch.

Q: What does it mean by "`merge` creates *unnecessary merge commits*"?  
A:  If multiple merges were needed in a feature branch, then the feature branch might even hold more merge commits than actual commits! Below is an example of Git hisotry when using `merge`:

<img src="https://drive.google.com/thumbnail?id=19_yD35xKrQxNCj3Wm4srQhPQGvZWI4-T&sz=w1000" alt="Git History–Merge" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />

Note the many commits starting with `Merge branch 'main' into ...`. They don't even exist if you rebase (there, you will only have pull request merge commits). Also many visual branch merge loops (`main` into `feature` into `main`).

Q: How does a Git history look like when using `rebase`?  
A: Much cleaner Git history with much less merge commits and no cluttered visual branch merge loops whatsoever. Looks like the following:

<img src="https://i.sstatic.net/0ZVla.png" alt="Git History–Rebase" style="display: block; margin-right: auto; margin-left: auto; zoom:80%;" />



___

## Squash Commits

"Commit early, commit often" is a popular mantra in software development when using Git. However, this can also lead to an overabundance of commits. 

This is where the importance of **squashing commits** comes into play. Commits can be combined into a single commits by squashing.

For instance, let’s say we work on a feature implementing a login form, and we create the following four commits:

<img src="https://media.datacamp.com/cms/google/ad_4nxepkfi_fk2rusomgitcluvwgugnbs2oza_bjuchte6ruirc16f0dazquz-u-orydd86wjtcvogcu65uaqp6io7v81rua-clwl8qhfghjbwkyv3rzn7_yhtdadxnrk_rnafzo6yvfl94rx6eocubjdj12bu4.png" alt="Git Commits" style="display: block; margin-right: auto; margin-left: auto; zoom:100%;" />

Once the feature is completed, for the overall project, these commits are too detailed. To ensure a clean history in the main branch, we squash these commits into a single commit:

<img src="https://media.datacamp.com/cms/google/ad_4nxdy6qebl2v13vucj5ujfcjlk8gzalksbgzcp-cwfss79wxphwz8wehu-jazlr1n1oozgy9o6cfric_v0h6p0ukcf6dagugsppct1igsaihqc_2wj7fpmm1ia_gq3afbnmawm34ums1zztvi5nea_hdq9cs.png" alt="Git Commits" style="display: block; margin-right: auto; margin-left: auto; zoom:100%;" />

The most common method to squash commits is using an i**nteractive rebase**. We start it using the command:

```bash
git rebase -i HEAD~<number_of_commits>
```

Replace `<number_of_commits>` with the number of commits we want to squash.

In our case, we have four commits, so the command is:

```bash
git rebase -i HEAD~4
```

Remember again that this is a rebasing command — every commit in the range `HEAD~4..HEAD` with a changed message *and all of its descendants* will be rewritten. 

❗️Don’t include any commit you’ve already pushed to a central server — doing so will confuse other developers by providing an alternate version of the same change.

Executing this command will open an interactive command-line editor that looks something like this:

<img src="https://media.datacamp.com/cms/google/ad_4nxfnhx6fbsnhqxse8v1-dmsxoot6xmhzsqfkgzc5eq7khh5w4sla3ltykvh1xq_sckuf4eoxniwwy3qkm8b9mmm1qpeuig-fjmstx3cap5abbmd11_fa8xwoxiyp8xk5gqkw98tsk_ltcr8oclr7dvy2p28p.png" alt="Git Commits" style="display: block; margin-right: auto; margin-left: auto; zoom:120%;" />

We see four commits that are listed in the opposite order. For each, we must decide which command to execute. We care about the `pick` (`p`) and `squash` (`s`) commands. 

To squash these four commits into a single commit, we can `pick` the first one and `squash` the remaining three.

After we have made the changes, the scirpt should look like:

<img src="https://media.datacamp.com/cms/google/ad_4nxc5xmf_a2xmkdnigtdculodeodfza_xymg7v8tdtemt8m7dh6rbkzcpizs4hmjrwmmwzlmnyg5us4w9xdm4fljw2huzgozf1pf2vpua5lchyllzpqq_y2timnisr2aldmvapcyqq7x8-f1phy4j4asz_wc.png" alt="Git Commits" style="display: block; margin-right: auto; margin-left: auto; zoom:120%;" />

When you save and exit the editor, Git will execute the script and open a new text editor. The editor will display a default message comprising the messages from the four commits we are squashing:

<img src="https://media.datacamp.com/cms/google/ad_4nxcy7ocys-cch426cwy9dmvlzei9kydusyp_wb_j822xsf_rh4yhvfu2aswmcln6ncxnr9qomtormn3gccjxd1ymwf4mgiig_wakluu2m0qesim62yave8vns_dlby14yzty3hr3fxquveqqlrvvkhxlbrc.png" alt="Git Commits" style="display: block; margin-right: auto; margin-left: auto; zoom:120%;" />

Enter the commit message to accurately reflect the changes implemented by these combined commits.

**Pusing Squashed Commits**

The command above will act on the local repository. To update the remote repository, we need to push our changes. However, because we changed the commit history, we need to force push using the `--force-with-lease` option:

```bash
git push --force-with-lease origin feature/login-form
```

This option ensures we only force push if the remote branch hasn't been updated since our last fetch or pull.



References:

<https://www.datacamp.com/tutorial/git-squash-commits>

<https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History>



___

## Gists

Q: When should I use a Gist instead of a full-fledged Git repo?  
A: Gist is meant for sharing code snippets. Usually, you either edit online directly or edit locally then copy-paste online, which will overwrite your whole hisotry. Not ideal if you want to track excactly what you changed every time.

- Gist: If it's pieces of code designed to demonstrate a technique, teach a principle, or show off a solution, it goes in a Gist.
- GitHub: If it's actual code intended to be run, used as is, or forked as boilerplate I put it in a proper repository. For each project, you build a Git repository, where you can have multiple directories and organize different file types, track changes, etc.

___

Q: Should I clone Gist locally so that I manage it as a regular Git repo?  
A: No, I wouldn't do it. Each Gist will be one folder named by the Gist ID. It is not human readable. You can put it in a parent folder with a readable name, but imagine you have many Gists, then you have many (at least) two-level folders.

There is a workaround if you really need to edit locally. You can use the [GistPad](https://marketplace.visualstudio.com/items?itemName=vsls-contrib.gistfs) extension on VS Code. You can open, create, delete, fork, archive, and star gists/repositories, and then seamlessly begin editing files **as if they were local**, without ever cloning, pushing or pulling anything. 

___

Q: How about put all Gist in one regular repo?  
A: Not goog as you are putting lots of unrelated things together.

___

























